## 语法
#### ECMAScript中的一切（变量、函数名和操作符）都区分大小写。
#### 标识符: 就是指变量、函数、属性的名字，或者函数的参数。
### 严格模式
#### ECMAScript5引入了严格模式（strict mode）的概念。严格模式是为了JavaScript定义了一种不同的解析与执行模型。在严格模式下，ECMAScript3中的一些不确定的行为将得到处理，而且对某些不安全的操作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代码:
#### "use strict"
#### 这行代码看起来像是字符串，而且也没有赋值给任何变量，但其实它是一个编译指令（pragma），用于告诉支持的JavaScript引擎切换到严格模式。这是为了不破坏ECMAScript3语法而特意选定的语法。
#### 在函数的内部的上方包含这条编译指令，也可以指定函数在严格模式下执行：
```javascript
function doSomething() {
    "use strict";
    //函数体
}
```
#### 严格模式下，JavaScript的执行结果会有很大不同。

## 变量
#### 有一点必须注意，即用`var`操作符定义的变量将成为定义该变量的作用域中的局部变量，也就是说，如果在函数中使用`var`定义一个变量，那么这个变量在函数退出后就会被销毁。

## 数据类型
### ECMAScript中有5种简单数据类型（也称为基本数据类型）:`Undefined`、`Null`、`Boolean`、`Number`和`String`。还有一种复杂数据类型--Object，Object本质上是由一组无序的名值对组成的。ECMAScript不支持任何创建自定义类型的机制，而所有值最终都将是上述6种数据类型之一。

### typeof操作符
#### 对一个值使用`typeof`操作符可能返回下列某个字符串:
- `undefined` —————— 如果这个值未定义
- `boolean` —————— 如果这个值是布尔值
- `string` —————— 如果这个值是字符串
- `number` —————— 如果这个值是数值
- `object` —————— 如果这个值是对象或null
- `function` —————— 如果这个值是函数

### Undefined类型
#### Undefined类型只有一个值，即特殊的undefined。在使用`var`声明变量但未对其加以初始化时，这个变量就是undefined

### Null类型
#### 如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。

#### 各种数据类型转布尔规则
|数据类型| 转换为true的值 | 转换为false的值 |
|:--:|:--:|:--:|
|Boolean|true|false|
|String|任何非空字符串|""(空字符串)|
|Number|任何非零数字值(包括无穷大)|0和NaN|
|Object|任何对象|null|
|Undefined|n/a|undefined|

#### 强制类型转换发生场景：
1. 字符串拼接
2. if判断
3. ==运算符
4. 逻辑运算

### Number类型
#### Number类型应该是ECMAScript中最令人关注的数据类型了，这种类型使用IEE754格式来表示整数和浮点数值(浮点数值在某些语言中也被称为双精度数值)。为支持各种数值类型，ECMA-262定义了不同的数值字面量格式。
#### 最基本的数值字面量格式是十进制整数，十进制整数可以像下面这样直接在代码中输入:
```javascript
var intNum = 55; //整数
```
#### 除了以十进制表示外，整数还可以通过八进制（以8为基数）或十六进制（以16为基数）的字面值来表示。其中，八进制字面值的第一位必须是零（0），然后是八进制数字序列（0~7）。如果字面值中的数值超出了范围，那么前导零将被忽略，后面的数值将被当作十进制数值解析。
```javascript
var octalNum1 = 070;  //八进制的56
var octalNum2 = 079;  //无效的八进制数值————解析为79
var octalNum3 = 08; //无效的八进制数值————解析为8
```
#### `八进制字面量在严格模式下是无效的`
### 浮点数值
#### 由于浮点数值需要的内存空间是保存整数值的两倍，因此ECMAScript会不失时机地将浮点数值转换为整数值。显然，如果小数点后面没有跟任何数字，那么这个数值就可以作为整数值来保存。
```javascript
var floatNum1 = 1.; //小数点后面没有数字————解析为1
var floatNum2 = 10.0; //整数————解析为10
```

#### 对于那些极大或极小的数值，可以用e表示法（即科学计数法）表示的浮点数值表示。
```javascript
var floatNum = 3.125e7; //等于31250000
```

### NaN
#### 两个特点：
- 任何涉及NaN的操作（例如NaN/10）都会返回NaN，这个特点在多步计算中可能导致问题。
- NaN与任何值都不相等，包括NaN本身。
```javascript
console.log(NaN == NaN); //false
```
#### 针对NaN这两个特点，ECMAScript定义了isNaN()函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否"不是数值"。

### 数值转换
#### 有三个函数可以把非数值转换为数值：Number()、parseInt()、parseFloat()。第一个函数，即转型函数Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。
#### parseInt()可以转换二进制、八进制、十进制的数字，但要在第二个参数，明确转换的位数；parseFloat只能转换十进制。

### String类型
#### 字符串的特点
##### ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。
##### toString()把一个值转换为字符串，数字默认转换为十进制的字符串表示形式，可以传进制进去，null、undefined不能使用toString()方法，报错，这时候可以使用String()转型函数，null、undefined转型后结果依然是null、undefined。还可以用加号操作符，把该值+""

### Object类型
#### ECMAScript中的对象其实就是一组数据和功能的集合。
#### ECMAScript中，Object类型是所有它的实例的基础。换句话说，Object类型所具有的任何属性和方法也同样存在于更具体的对象中。
#### Object的每个实例都具有下列属性和方法
- `constructor`: 保存着用于创建当前对象的函数。
- `hasOwnProperty(propertyName)`: 用于检查给定的属性在当前对象实例中（而不是实例原型中）是否存在。其中，作为参数的属性名（propertyName）必须以字符串形式指定（例如： o.hasOwnProperty("name")）
- `isPrototypeOf(object)`: 用于检查传入的对象是否是当前对象的原型。
- `propertyIsEnumerable(propertyName)`: 用于检查给定的属性是否能够使用for-in语句来枚举。与hasOwnProperty()方法一样，作为参数的属性名必须以字符串形式指定。
- `toLocaleString()`: 返回对象的字符串表示，该字符串与执行环境的地区对应。
- `toString()`: 返回对象的字符串表示。
- `valueOf()`: 返回对象的字符串、数值或布尔值表示。通常与toString()方法的返回值相同。
> 从技术角度讲，ECMA-262中对象的行为不一定适用于JavaScript中的其他对象。浏览器环境中的对象，比如BOM和DOM中的对象，都属于宿主对象，因为它们是由宿主实现提供和定义的。ECMA-262不负责定义宿主对象，因此宿主对象可能会也会能不会继承Object。

## 操作符
#### 执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。
#### 后置递增和递减与前置递增和递减有一个非常重要的区别，即递增和递减操作是在包含它们的语句被求值之后才执行的。
### 一元加和减操作符
#### 在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值执行转换。换句话说，布尔值false和true将被转换为0或1，字符串值会被按照一组特殊的规则进行解析，而对象是先调用它们的`valueOf`和(或)`toString()`方法，再转换得到的值。
#### 一元加和减操作符主要用于基本的算数运算。

### 布尔操作符
#### 同时使用两个逻辑非操作符，实际上就会模拟`Boolean()`转型函数的行为。

#### 逻辑与操作属于短路操作，即如果第一个操作数能够决定结果，那么就不会再对第二个操作数求值。对于逻辑与操作而言，如果第一个操作数是false，则无论第二个操作数是什么值，结果都不再可能是true了。

#### 逻辑或操作符也是短路操作符。也就是说，如果第一个操作数的求值结果为true，就不会对第二个操作数求值了。

#### 我们可以利用逻辑或的这一行为来避免为变量赋null或undefined值。例如：
```javascript
var myObject = preferredObject || backupObject;
```

### 关系操作符
#### 当关系操作符的操作数使用了非数值时，也要进行数值转换或完成某些奇怪的操作。以下就是相应的规则。
- 如果两个操作数都是数值，则执行数值比较。
- 如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。
- 如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。
- 如果一个操作数是对象，则调用这个对象的`valueOf()`方法，用得到的结果按照前面的规则执行比较。如果对象没有`valueOf()`方法，则调用toString()方法

#### 在使用关系操作符比较两个字符串时，会执行一种奇怪的操作。很多人认为，在比较字符串值时，小于的意思是“在字母表的位置靠前”，而大于则意味着“在字母表中的位置靠后”，但实际完全不是那么回事。在比较字符串时，实际比较的是两个字符串中对应位置的每个字符的字符编码值。经过这么一番比较之后，再返回一个布尔值。由于大写字母的字符编码全部小于小写字母的字符编码，因此我们就会看到如下所示的奇怪现象：
```javascript
var result = "Brick" < "alphabet" //true
```
#### 在这个例子中，字符串“Brick”被认为小于字符串“alphabet”。原因是字母B的字符编码为66，而字母a的字符编码是97.如果要真正按字母表顺序比较字符串，就必须把两个操作数转换为相同的大小写形式（全部大写或全部小写），然后再执行比较，如下所示：
```javascript
var result = "Brick".toLowerCase() < "alphabet".toLowerCase() //false
```

#### 另一种奇怪的现象发生在比较两个数字字符串的情况下，比如下面这个例子：
```javascript
var result = "23" < "3"; //true
```
#### 确实，当比较字符串"23"是否小于"3"时，结果居然是true。这是因为两个操作数都是字符串，而字符串比较的是字符编码（"2"的字符编码是50，而"3"的字符编码是51）。不过，如果像下面例子中一样，将一个操作数改为数值，比较的结果就正常了：
```javascript
var result = "23" < 3; //false
```

#### 可是，如果那个字符串不能被转换成一个合理的数值。
```javascript
var result = "a" < 3; //false,因为"a"被转换成了NaN
```
#### 由于字母"a"不能转换成合理的数值，因此就被转换成了NaN。根据规则，任何操作数与NaN进行关系比较，结果都是false。于是，就出现了这个有意思的现象:
```javascript
var result = NaN < 3; //false
var result = NaN >= 3; //false
```
#### 按照常理，如果一个值不小于另一个值，则一定是大于或等于那个值。然而，在与NaN进行比较时，这两个比较操作的结果都返回了false.

### 相等操作符
#### 相等操作符在进行比较时则要遵循下列规则。
- `null`和`undefined`是相等的。
- 要比较相等性之前，不能将`null`和`undefined`转换成其他任何值。
- 如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作符都是NaN，相等操作符也返回false；因为按照规则，NaN不等于NaN.
- 如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。
#### 下表列出了一些特殊情况及比较结果：
|表达式| 值 | 
|:--:|:--:|
|null == undefined|true|
|"NaN" == NaN|false|
|5 == NaN|false|
|NaN == NaN|false|
|NaN != NaN|true|
|false == 0|true|
|true == 1|true|
|true == 2|false|
|undefined == 0|false|
|null == 0|false|
|"5" == 5|true|
